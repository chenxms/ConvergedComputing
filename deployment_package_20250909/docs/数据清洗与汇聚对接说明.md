# 数据清洗与汇聚对接说明（当前实现与集成契约）

本文档面向后续的 AI 开发工程师，完整说明我们当前的数据清洗实现、数据库结构与字段口径、触发与校验方式，以及与数据汇聚（统计/报表）对接所需的契约与注意事项。根据本说明，你应能独立完成后续的汇聚实现与联调。

## 1. 总体目标与范围

- 目标：将原始明细数据清洗为标准的学生级科目总分与可选维度分，形成稳定的下游输入；同时为问卷题目生成明细与选项分布。
- 范围：
  - 考试类与互动类（`question_type_enum IN ('exam','interaction')`）按题逐和生成总分与维度分；
  - 问卷类（`questionnaire`）生成“每生×每题”明细、物化选项分布，并写入学生级问卷总分（用于统一看板/汇聚）。
- 入口：后端服务中的 `DataCleaningService.clean_batch_scores(batch_code)`，支持 CLI/容器/API 触发。

## 2. 关键实现与修复概述

- 统一“总分口径”：考试/互动全部按题逐和，不再直接使用原始 `total_score` 字段。
- 问卷清洗改为单条 SQL 管道（INSERT…SELECT via JOIN + JSON_EXTRACT），彻底避免 Python 循环与 JSON 键含连字符的问题；`instrument_type` 明确等于配置中的 `instrument_id`。
- 物化问卷选项分布基于明细数据按比例四舍五入映射到 `option_level`，并写入 `questionnaire_option_distribution`。
- 写入学生级问卷总分到 `student_cleaned_scores`（`subject_type='questionnaire'`），与考试/互动统一看板口径对齐。
- 常见坑位处理：
  - 学生 ID 可能含非数字字符 ⇒ 在 SQL 插入时使用 `REGEXP '^[0-9]+$'` 过滤并 `CAST(... AS UNSIGNED)`；
  - 不同表 `collation` 不一致导致 1267 ⇒ 跨表 JOIN、过滤处使用 `BINARY` 强制按字节比较；
  - MySQL `ONLY_FULL_GROUP_BY` ⇒ 物化分布改为子查询后再分组计数；
  - 唯一键冲突 ⇒ `student_cleaned_scores` 存在唯一键（批次×学生×科目），清洗前会清理该批次旧数据。

## 3. 数据库表与字段（对接最小集）

以下为清洗与汇聚所需的核心表及字段约定。未列出者属于扩展字段，非强依赖。

### 3.1 原始明细表 `student_score_detail`
- 必备字段：
  - `batch_code` VARCHAR：批次代码（示例：`G4-2025`）
  - `subject_name` VARCHAR：科目名称（示例：`数学`、`问卷`）
  - `student_id` VARCHAR：学生标识（可能含非数字字符）
  - `student_name` VARCHAR
  - `school_id` VARCHAR / BIGINT（实现已兼容）
  - `school_code` VARCHAR
  - `school_name` VARCHAR
  - `class_name` VARCHAR
  - `subject_id` VARCHAR
  - `subject_scores` JSON：题目分数字典，键为 `question_id`（可能含连字符，如 `s1-1`），值为数值
  - `total_score` DECIMAL（考试/互动不再直接使用）

### 3.2 题目配置表 `subject_question_config`
- 必备字段：
  - `batch_code`、`subject_name`
  - `question_id`（与 `subject_scores` 中键对应）
  - `question_number`/`question_no`（任选其一用于展示）
  - `max_score` DECIMAL：题目满分
  - `question_type_enum` ENUM：`exam` / `interaction` / `questionnaire`
  - `instrument_id` VARCHAR（问卷量表 ID；清洗中作为 `instrument_type`）

### 3.3 清洗后学生表 `student_cleaned_scores`
- 插入字段（考试/互动）：
  - `batch_code`、`student_id`、`student_name`、`school_id`、`school_code`、`school_name`、`class_name`
  - `subject_id`、`subject_name`
  - `total_score`、`max_score`
  - `question_count` INT、`is_valid` TINYINT（1/0）
  - `dimension_scores` JSON、`dimension_max_scores` JSON
  - `subject_type` ENUM：`exam` / `questionnaire`
- 插入字段（问卷）：同上，但 `subject_type='questionnaire'`，`total_score` 为问卷逐题总分，`max_score` 为问卷题目 `SUM(max_score)`。
- 重要约束：存在唯一键 `uk_batch_student_subject`（批次×学生×科目），清洗会先删除旧记录再插入。

### 3.4 问卷明细表 `questionnaire_question_scores`
- 插入字段：
  - `batch_code`、`subject_name`、`student_id`（数值化后插入）
  - `question_id`、`original_score`、`max_score`
  - `scale_level` INT（由 `instrument_id` 启发式提取 10/7/5/默认4）
  - `instrument_type` VARCHAR（等于 `instrument_id`）
  - `is_reverse` TINYINT（当前固定 0；若后续有反向量表可调整）
- 说明：表结构可能包含更多展示字段（如 `dimension_code/name`、`question_name`、`option_label/level`），当前 SQL 管道仅填充必要字段以稳定落地。

### 3.5 问卷分布表 `questionnaire_option_distribution`
- 字段：`batch_code`、`subject_name`、`question_id`、`option_level`、`count`、`updated_at`
- 来源：基于 `questionnaire_question_scores` 按比例映射 `option_level` 后聚合得到（四舍五入到 1..scale_level）。

### 3.6 维度配置（供考试/互动维度分）
- `batch_dimension_definition`：`batch_code`、`subject_name`、`dimension_code`、`dimension_name`
- `question_dimension_mapping`：`batch_code`、`subject_name`、`question_id`、`dimension_code`

### 3.7 量表选项（可选）`questionnaire_scale_options`
- 字段：`instrument_type`、`scale_level`、`option_level`、`option_label`、`option_description`、`is_reverse`
- 用途：如需展示标准的选项标签，可在读端或额外物化时与本表 JOIN。

## 4. 清洗逻辑（服务与 SQL 模板）

### 4.1 服务位置
- `data_cleaning_service.py`：
  - `_clean_subject_scores`：考试/互动，按配置题目 ID 从 `subject_scores` JSON 逐题求和，计算维度分，写入 `student_cleaned_scores`；
  - `_clean_questionnaire_scores`：问卷，使用单条 SQL 管道完成明细/分布/汇总；`instrument_type`= `instrument_id`；
  - `clean_batch_scores(batch_code)`：批次入口，先清理旧数据，再逐科目处理。

### 4.2 考试/互动（逐题求和）
- 取题：`SELECT question_id FROM subject_question_config WHERE question_type_enum IN ('exam','interaction')`。
- 求和：仅累加上述题目的 JSON 分值（忽略缺失/非数值）。
- 维度：按 `question_dimension_mapping` 与 `batch_dimension_definition` 聚合到维度分与满分。
- 写入：`student_cleaned_scores`（`subject_type='exam'`）。

### 4.3 问卷（SQL 管道，稳定落地）
1) 清理旧明细：
```sql
DELETE FROM questionnaire_question_scores
WHERE BINARY batch_code=BINARY :batch AND BINARY subject_name=BINARY :subject;
```
2) 插入明细（每生×每题）：
```sql
INSERT INTO questionnaire_question_scores
(batch_code, subject_name, student_id, question_id, original_score, max_score, scale_level, instrument_type, is_reverse)
SELECT ssd.batch_code,
       ssd.subject_name,
       CAST(ssd.student_id AS UNSIGNED),
       sqc.question_id,
       CAST(JSON_UNQUOTE(JSON_EXTRACT(ssd.subject_scores, CONCAT('$."', sqc.question_id, '"'))) AS DECIMAL(10,2)) AS original_score,
       sqc.max_score,
       CASE WHEN sqc.instrument_id LIKE '%10%' THEN 10
            WHEN sqc.instrument_id LIKE '%7%' THEN 7
            WHEN sqc.instrument_id LIKE '%5%' THEN 5
            ELSE 4 END AS scale_level,
       sqc.instrument_id AS instrument_type,
       0 AS is_reverse
FROM student_score_detail ssd
JOIN subject_question_config sqc
  ON BINARY sqc.batch_code=BINARY ssd.batch_code
 AND BINARY sqc.subject_name=BINARY ssd.subject_name
 AND sqc.question_type_enum='questionnaire'
WHERE BINARY ssd.batch_code=BINARY :batch
  AND BINARY ssd.subject_name=BINARY :subject
  AND JSON_EXTRACT(ssd.subject_scores, CONCAT('$."', sqc.question_id, '"')) IS NOT NULL
  AND ssd.student_id REGEXP '^[0-9]+$';
```
3) 物化分布：
```sql
REPLACE INTO questionnaire_option_distribution
(batch_code, subject_name, question_id, option_level, count, updated_at)
SELECT batch_code, subject_name, question_id, option_level, COUNT(*), NOW()
FROM (
  SELECT batch_code, subject_name, question_id,
         GREATEST(1, LEAST(scale_level, ROUND(COALESCE(original_score,0)/NULLIF(max_score,0)*scale_level, 0))) AS option_level
  FROM questionnaire_question_scores
  WHERE BINARY batch_code=BINARY :batch AND BINARY subject_name=BINARY :subject
) x
GROUP BY batch_code, subject_name, question_id, option_level;
```
4) 学生级问卷总分：
```sql
DELETE FROM student_cleaned_scores
WHERE batch_code=:batch AND subject_name=:subject AND subject_type='questionnaire';

INSERT INTO student_cleaned_scores
(batch_code, student_id, student_name, school_id, school_code, school_name, class_name,
 subject_id, subject_name, total_score, max_score, question_count, is_valid,
 dimension_scores, dimension_max_scores, subject_type)
SELECT :batch,
       CAST(ssd.student_id AS UNSIGNED), ssd.student_name, ssd.school_id, ssd.school_code, ssd.school_name, ssd.class_name,
       ssd.subject_id, :subject,
       ROUND(SUM(qqs.original_score),2) AS total_score,
       (SELECT SUM(max_score) FROM subject_question_config sqc2
         WHERE BINARY sqc2.batch_code=BINARY :batch AND BINARY sqc2.subject_name=BINARY :subject AND sqc2.question_type_enum='questionnaire') AS max_score,
       (SELECT COUNT(*) FROM subject_question_config sqc3
         WHERE BINARY sqc3.batch_code=BINARY :batch AND BINARY sqc3.subject_name=BINARY :subject AND sqc3.question_type_enum='questionnaire') AS question_count,
       1, '{}', '{}', 'questionnaire'
FROM questionnaire_question_scores qqs
JOIN student_score_detail ssd
  ON BINARY ssd.batch_code=BINARY qqs.batch_code
 AND BINARY ssd.subject_name=BINARY qqs.subject_name
 AND ssd.student_id=qqs.student_id
WHERE BINARY qqs.batch_code=BINARY :batch AND BINARY qqs.subject_name=BINARY :subject
GROUP BY ssd.student_id, ssd.student_name, ssd.school_id, ssd.school_code, ssd.school_name, ssd.class_name, ssd.subject_id;
```

## 5. 触发与校验

### 5.1 触发方式
- CLI/脚本：
  - `single_batch_cleaner.py` / `batch_cleaning_runner.py`（容器或本地，需 `DATABASE_URL`）
- API（已新增，便于前端按钮触发）：
  - 触发清洗：`POST /api/v1/management/batches/{batch_code}/clean`
  - 查状态：`GET /api/v1/management/tasks/{task_id}/status`
  - 查进度：`GET /api/v1/management/tasks/{task_id}/progress`

### 5.2 快速校验 SQL（只读）
- 问卷明细行数/学生数：
```sql
SELECT subject_name, COUNT(*) rows, COUNT(DISTINCT student_id) students
FROM questionnaire_question_scores WHERE batch_code='G4-2025' GROUP BY subject_name;
```
- 问卷分布行数：
```sql
SELECT subject_name, COUNT(*) rows
FROM questionnaire_option_distribution WHERE batch_code='G4-2025' GROUP BY subject_name;
```
- 学生级问卷汇总：
```sql
SELECT subject_name, COUNT(*) rows, COUNT(DISTINCT student_id) students, MAX(max_score) max_score
FROM student_cleaned_scores WHERE batch_code='G4-2025' AND subject_type='questionnaire' GROUP BY subject_name;
```
- 一致性抽查（50人，明细求和 VS 汇总）：
```sql
SELECT student_id, ROUND(SUM(original_score),2) total
FROM questionnaire_question_scores
WHERE batch_code='G4-2025' AND subject_name='问卷' GROUP BY student_id LIMIT 50;

SELECT student_id, ROUND(total_score,2) total
FROM student_cleaned_scores
WHERE batch_code='G4-2025' AND subject_type='questionnaire' AND subject_name='问卷' LIMIT 50;
```

## 6. 与数据汇聚的对接契约

### 6.1 汇聚的主数据源
- 学生级清洗表：`student_cleaned_scores`
  - 字段稳定，包含：学生、学校、科目、总分/满分/题量/维度 JSON、`subject_type`。
  - 考试/互动行：`subject_type='exam'`；问卷行：`subject_type='questionnaire'`。

### 6.2 问卷细分需要
- 若需要题目/选项分布与维度报表：
  - 题目层数据：`questionnaire_question_scores`
  - 选项分布：`questionnaire_option_distribution`
  - 标签映射（可选）：`questionnaire_scale_options` 与 `instrument_type/scale_level/option_level` 关联得到标准 `option_label`

### 6.3 维度分析（考试/互动）
- 维度配置：`batch_dimension_definition` + `question_dimension_mapping`
- `student_cleaned_scores.dimension_scores` 与 `dimension_max_scores` 已按配置聚合，汇聚可直接展开 JSON 做统计。

### 6.4 Collation 与连接注意
- 表建议统一为 `utf8mb4_0900_ai_ci`（或同一套），否则跨表等值比较需 `BINARY`；
- 如需在读端 JOIN 问卷明细与学校/学生信息，留意 `student_id` 类型（部分数据为字符串）。本实现对写入做了数值过滤与转换，但读端仍建议视表结构采用兼容的联结方式。

## 7. 运行样例（G4-2025 / 问卷）

- 明细行数：`42896`
- 学生数：`1532`
- 分布行数：`112`
- 学生级问卷汇总行数：`1532`，`max_score=112`
- 说明：具体数值随环境与数据变更而不同，以上为当前一次执行结果快照，主要作为量级参考与回归对照。

## 8. 代码与入口参考

- 服务实现：`data_cleaning_service.py`
- 管理接口：
  - `app/api/management_api.py`（清洗触发与任务查询）
  - `app/services/task_manager.py`（任务生命周期与后台执行）
- 典型调用：
  - 触发清洗：`POST /api/v1/management/batches/{batch_code}/clean`
  - 轮询进度：`GET /api/v1/management/tasks/{task_id}/progress`

## 9. 未来扩展与替换点

- 精确量表映射：如提供权威的 `questionnaire_scale_options` 与题目维度表，可在清洗阶段直接 JOIN 生成 `option_label` 与维度字段，减少读端计算。
- 统一 Collation：生产库层面统一 `utf8mb4_0900_ai_ci` 或 `utf8mb4_general_ci`，可去除大部分 `BINARY` 比较与 1267 风险。
- 非数字学生 ID：如需保留所有学生，考虑将 `student_id` 统一建为 VARCHAR，并在读端做兼容；当前实现仅插入纯数字 ID 至问卷明细与汇总。

---

依据本说明：
- 你可以直接从 `student_cleaned_scores` 拉取学生级总分/满分/维度 JSON 作为汇聚输入；
- 对问卷可从 `questionnaire_question_scores` 与 `questionnaire_option_distribution` 获取题目与选项层统计；
- 触发与回归均可通过提供的管理 API 完成；
- 若新增题型或量表映射，按第 9 节替换点调整即可保持契约不变。

